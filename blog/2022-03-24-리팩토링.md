---
slug: long
title: 리팩토링 계획
authors: nick
tags: [Getcha, FrontEnd]
---

리팩토링 계획을 만들어봤습니다.

## 방향성

1. 한눈에 파악 가능한 **구조** 만들기
2. 지속가능한 코드 만들기

---

# 파일 정리

### 안쓰는 파일 정리

현재 사용하지 않는 파일, 폴더를 삭제합니다.

추후 사용될 여지가 있는 파일들은 git에 branch로 따로 남겨두면 됩니다.

## 폴더 정리

폴더 구조가 한눈에 알아보기 힘들고 일관성이 없어 향후 유지보수를 위해 폴더 이름, 파일구조 컨벤션을 정하고 일괄 변경 작업을 진행하겠습니다.

## 안쓰는 코드 정리

단순 주석이나 코드 내에서도 쓰이지 않는 코드 제거가 필요합니다.

### + 하면 좋은 정리

1. 중복 코드 제거
2. 중복 로직 묶기
3. ...

---

# Component Library

getcha-app의 크기가 너무 커서 이를 분리하는 작업이 필요하다고 생각합니다. 제가 생각하는 첫번째 단계는 컴포넌트 라이브러리입니다. 자주 사용하는 컴포넌트를 라이브러리로 묶어서 npm package로 관리하면 관리도 쉽고 일관성도 유지할 수 있으며 방대한 양의 코드를 분리시킬 수 있습니다. 또한 있는지 몰라서 다시 만드는 일이 줄어듭니다. 겟차 프론트엔드 툴킷 정도로 활용되면 좋을 것 같아요.

💡 예를 들면 [react-native-element](https://reactnativeelements.com/docs)가 있습니다.

현재 프로덕트 디자인 팀에서 디자인 시스템을 구축중에 있습니다. 해당 작업과 연계해서 진행되면 좋을 것 같습니다. 참고하고 계시는 시스템은 [Socar의 디자인 프레임](https://socarframe.socar.kr/8bb3aba4a/p/480a5e-introduction)입니다.

## 라이브러리 구조

### GetchaComponent

index에서는 공통으로 필요한 데이터들을 선언해두고 가져다 쓰면 좋을 것 같습니다. 예를 들어 환경변수가 아닌 Const 값이나 이벤트 함수같은 부분들은 서비스 의존적이라 조금이라도 변경하려면 다시 배포를 하거나 코드푸시를 해서 버전관리를 어렵게 만드니 이렇게 관리하면 좋지 않을까 생각합니다.

React App과 Web이 지금처럼 같이 간다면 이 폴더 안에 컴포넌트를 다 넣어도 좋을 것 같은데, 추후 분리가 예정되어있어 아래와 같이 따로 나누는게 좋을 것 같습니다.

### GetchaComponent/web

React 용 Component가 있습니다.

웹에서만 사용되는 컴포넌트나 웹용 컴포넌트가 정의되어 있습니다.

### GetchaComponent/App

React Native용 Component가 있습니다.

### GetchaComponent/Hooks

Getcha에서 공통으로 사용되는 Hook들이 있습니다.

조금 더 확장해보면 Hooks라는 이름을 Utils같은 이름으로 고쳐서 전역에서 사용하거나 사양될 Context나 HOC 등을 같이 넣어주면 좋을 것 같습니다. util 함수도 같이 들어간다면 좋을 것 같아요.

:::tip 유용한 훅 모음

💡 [예시1](https://usehooks.com/), [예시2](https://usehooks-ts.com/)

:::

### Getcha - ??

뭐 더 넣을지 **추천받습니다**

---

### + FrontEnd 개발용 Document 만들기

디자인 팀에서는 [zeroHeight](https://zeroheight.com/)라는 프레임워크를 사용할 생각인 것 같습니다. 디자인에 특화되어있고, 공통 컴포넌트 및 디자인 시스템에 있어서 피그마를 대체할만한 프레임워크라 생각되어 괜찮은 것 같습니다.

개발팀에서는 조금 더 활용방법 및 개발에 가져다 쓰는 방식을 고려하여 도큐먼트를 따로 만들 생각입니다. 저희는 [도큐사우루스](https://docusaurus.io/ko/)나 [깃북](https://www.gitbook.com/)를 활용하면 좋을 것 같습니다.

---

# Store

현재 Redux, Redux-Saga로 구현되어있는 전역 Store는 크기가 매우 커서 관리가 많이 힘듭니다. Store하나 추가하기 위해 작성해야하는 코드가 많고, 복붙을 많이 해야합니다.

전역 데이터의 범위를 제한하는 장치도 있어야 한다고 생각합니다. 전역 데이터의 가장 큰 문제는 어디선가 필요에 의해 가져다 쓰고, 지우지 않거나 잘못 가져다 써서 side effect를 발생시키는 것이기 때문입니다.

데이터 관리 구조 또한 파편화되어있어 클라이언트 내에서 같은 타입 이면서 같은 id인 데이터가 서로 다르게 표기되는 문제가 발생합니다. (예를 들면, 게시글 상세에서 댓글을 쓰고 나와도 리스트 데이터에서 댓글 갯수가 변화가 없는)

## 개선안 (다양한 의견이 필요함!)

![스크린샷 2022-04-20 오후 1.51.33.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0b72db7c-d912-4129-bbbf-1ee7e149b13e/스크린샷_2022-04-20_오후_1.51.33.png)

현재 구조처럼 특정 key가 하나의 타입 데이터를 가지는 구조가 아니라 받은 데이터는 타입별로 Store를 만들어 관리합니다. 그리고 데이터를 렌더링할 key는 id값만 가지고 해당 type의 Store의 reference를 받아다 렌더링합니다.

![현재의 구조](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29180ea3-e8e5-4c15-9f1a-d302b3d7f314/스크린샷_2022-04-20_오후_12.11.20.png)

현재의 구조

변경하게 된다면 아래와 비슷하게 적용될 것입니다.

```tsx
// Store by Types 구조 예시
communities: [{id:1, ...}, {id: 2...}, {id: 3 ...} ]
forums: [{id: 1, ...}, {id: 4, ...}]

// Store by Render 구조 예시
bookmarkFeeds: {
	page: {total_contents: 100},
	references: [1, 3, 5, 7, ...]
}
forums: {
	page: {...},
	references: [12,44,555, ...]
}
```

조회수나 추천같은 로직은 간단하게 요청 성공여부만 확인하고 id로 객체를 찾아 고쳐주면 되고 너무 오랬동안 캐시를 조작하면 안되니 적당한 주기로 풀링을 해서 syncronize할 수도 있습니다.

### 장점

1. 데이터 파편화를 완벽하게 해결할 수 있다.
2. 양방향 캐시 적용으로 속도가 많이 올라간다.
3. 조회수 같이 조금만 바뀌어도 리페칭해야하는 로직을 개선할 수 있다.
4. 서버 호출을 최소화할 수 있다.

### 단점 or 우려사항

1. 테스트를 안해봐서 성능을 보장할 수 없다.
2. 작업량이 엄청나다
3. 캐시 직접접근 시 치명적인 버그가 발생할 수 있다.

---

## React Query - Server State Library

클라이언트 스토어와 서버 스토어를 분리시킬 수 있는 프레임워크입니다.

현재 구조를 복잡하게 만드는 부분 중 하나인 Loading, Error, Data 객체를 각각 생성 & 관리해야하는 문제를 해결해주고, Client에서만 사용하는 Store만 남기고 Server Data State는 전부 React Query로 대체할 수 있습니다.

Redux 자체가 나온지 오래되었기 때문에 안정적이지만 사용 자체가 불편하고 복잡하다는 단점이 있습니다. 비교적 최근에 나온 가볍고 간단하며 성능좋은 상태관리 프레임워크로 넘어갈 수 있습니다.

## Client State Libraries

관리가 쉽고, 과도한 리렌더링 이슈를 해결하는데 목적을 두고 만들어진 라이브러리들입니다.

Zustand

[Zustand](https://zustand.surge.sh/)

Jotai

[Jotai, primitive and flexible state management for React](https://jotai.org/)

---

# typeScript

## typeScript 기반 컨벤션 결정 및 문서 작성

typeScript로 전환하기 전에 FrontEnd chapter 내에서의 Consensus가 도출되어야 합니다. 이를 기반으로 가이드 Docs가 만들어지면 일괄 적용하는 방식으로 진행하겠습니다.

## typeScript로 전환

1. type 정의

   글로벌 타입, aliasing, 상속관계 등등 여러가지 요소를 고려해야 함.

2. type Guard 선언

   현재 undefined에 map을 돌리거나 undefined에 dot notation으로 접근하며 런타임에 앱이 터지는 사례가 많은데, 이 부분들을 전부 typeGuard로 방어가 가능합니다.

   ```tsx
   // 이 함수가 true를 리턴하면서 Event 객체임을 보증한다.
   export const isEvent = (event: unknown): event is EVENT => {
     return (
       event !== null &&
       event !== undefined &&
       !!event.action &&
       !!event.payload
     );
   };

   // 이 함수를가 true를 리턴하면 Event 객체 배열임을 보증한다.
   export const isEvents = (events: unknown[]): events is EVENT[] => {
     return Array.isArray(events) && events.every(isEvent);
   };
   ```

3. util함수 정리

   현재 유틸함수는 Service 폴더 아래 파일형태로 존재합니다. 따로 묶음이 필요합니다. 유틸함수는 공용 함수이기 때문에 타입을 고려하지 않고 배열, 객체연산 등을 잘못 사용하면 곧바로 앱이 죽습니다. typeScript를 적용하고 주석으로 명확하게 표시해줘야 안전하고 효율적으로 사용할 수 있습니다.

   | 폴더 이름   | 함수들 예시                     |
   | ----------- | ------------------------------- |
   | nullChecker | isNull, isBoolean, isArray ...  |
   | numbers     | addCommas, numberWithSuffix ... |
   | regExp      | emailReg, phoneNumberReg, ...   |

4. navigation params 정의

   params 또한 오타나 잘못 사용하는 사례에 치명적입니다. 없거나 잘못 받는다면 다른 스크린으로 이동하는 순간 앱이 터지기 때문입니다. Navigation에도 타입을 정의할 수 있으니 이 부분도 적용하는 게 좋겠습니다.

5. 뭘 더 할까..

# Test Code & Auto Testing

## TDD(Test Driven Development)

결론부터 말하면 TDD를 하고싶진 않습니다. 개인적으로 그 작업들은 너무 많은 공수가 들기 때문에 비효율적이라 생각합니다.

하지만 Runtime에 앱이 죽는 경우를 방지하기 위해 다양한 케이스를 테스트할 수 있는 테스트코드를 템플릿처럼 만들어두고, 복붙 → 변수명 바꾸기 정도로 유지하면 어떨까 합니다.

## Auto Testing

우아한 형제들 기술블로그에서 [Appium으로 테스트 자동화를 구축했던 포스트](https://techblog.woowahan.com/2658/)를 본 적 있습니다. 지정된 시나리오대로 빠지는 것 없이 테스트하고 테스트 결과 리포트까지 작성해주면, 테스터는 해당 결과 중 오작동하는 부분만 테스트하면 될 겁니다.

현재 진행되는 주간 QA도 개발단에서 마무리지을 수 있고, 지금처럼 제한된 시간과 제한된 리소스만 가지고 테스트하기보다 더 많은 시나리오와 세분화된 환경(CPU throttle, Network Speed) 등을 고려해서 테스트할 수 있다고 생각합니다.

저희 서비스는 간헐적인 버그가 많습니다. 그만큼 다양한 환경과 기기에서 여러번 테스트하는게 안좋은 사용자 경험을 발견에 있어 중요합니다.

---

# Functional Programming

Pure Function만으로 코드를 작성하는 패러다임입니다. 저희 서비스 코드 내부에도 일부 적용되어 있지만 전반적으로 적용하려면 합의와 동의가 필요합니다.

함수형 프로그래밍을 적용하면 다음과 같은 이점이 있습니다.

1. 코드 가독성 상승 (개인차 존재)
2. 메모리 사용률 감소
3. side effect 감소 (참조 무결성 확보)

단점은 다음과 같습니다.

1. 기본적으로 사용되는 메소드, 커스터마이징한 함수들을 다 알고 있어야 효과적이다.
2. 반대로 가독성을 떨어뜨릴 수 있다.
   예를 들어 함수 이름을 이상하게 지은 경우
3. 리액트의 구조와 조금 안맞을 수 있다.
   리액트의 경우 props로 받은 데이터나 store 데이터를 직접 접근해서 이를 참조하거나 수정해서 렌더링하는 구조인데, FP에서는 Pure Function은 외부 참조를 불허하기 때문.

만약 사용하게 된다면, 아래와 같은 함수형 프로그래밍 라이브러리를 하나 정해서 사용하면 좋을 것 같습니다.

[Ramda](https://ramdajs.com/)

[Lodash](https://lodash.com/)

[Underscore.js](https://underscorejs.org/)
